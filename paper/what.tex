From quantum mechanics, we learn that the world is defined by Hilbert spaces
that evolve according to unitary transformations.\citeme{find something}

\begin{definition}[Hilbert space]\label{def:hilbert-space}
  \asz{This is a (slightly modified) quote from the Wikipedia article on Hilbert
  spaces; we need something better.}  ``A \term{Hilbert space} $H$ is a complex
  inner product space that is also a complete metric space with respect to the
  distance function induced by the inner product.''
\end{definition}

\begin{definition}[Conjugate transpose]\label{def:conjugate-transpose}
  The \term{conjugate transpose} of a matrix $M = (M_{i,j}) \in \C^{m \cross
  n}$, written $M^\dag$, is given by taking the complex conjugate of each
  element of $M^\T$; in other words, $M^\dag = (\overline{M_{j,i}})$.
\end{definition}

\begin{definition}[Hermitian matrix]\label{def:hermitian}
  A matrix $M$ is \term{Hermitian} if $M = M^\dag$.
\end{definition}

\begin{definition}[Unitary matrix]\label{def:unitary-matrix}
  A \term{unitary matrix} is a square matrix $U \in \C^{n \cross n}$ such that
  $U^\dag U = I$.\asz{Wikipedia defines a unitary \emph{transformation} as an
  isomorphism of Hilbert spaces, or a linear transformation that preserves the
  inner product.  Should we mention this?}
\end{definition}

We also need to briefly touch on notation.  We adopt the physicists' convention
of writing $\ket{\psi}$ for an element of a Hilbert space $H$; this is referred
to as a \term{ket}.  The dual of a ket is a \term{bra}, written $\bra{\phi}$,
which is an element of $H$'s dual space.  When working with vectors in $\C^n$,
as we will be doing, we can define $\bra{\psi} = \ket{\psi}^\dag$: where kets
are column vectors, bras are row vectors.  The notation $\braket{\phi | \psi}$
then denotes the inner product of $\ket{\phi}$ and $\ket{\psi}$, which is just
matrix multiplication in the case of $\C^n$.  Importantly, this means that we
have now also adopted the physicist's convention that the inner product is
linear in its \emph{second} argument, and conjugate-linear in its \emph{first}.

Fortunately, for quantum computation, we are only interested in very particular
Hilbert spaces.  These are the spaces that arise from considering the single
fundamental primitive datum of quantum computation: the \term{qubit}.  A qubit
is a \emph{qu}antum \emph{b}it: when we have a classical bit, we know that it is
either $0$ or $1$; similarly, when we measure a qubit, we know that we will get
either $\ket{0}$ or $\ket{1}$.  The difference between a qubit and a bit lies in
the word ``measure'': as long as we \emph{don't} measure a qubit, it can take on
all sorts of crazy states.  Formally, we can represent a qubit as an element of
$\C^2$ subject to some normalization constraints:

\begin{definition}[Qubit]\label{def:qubit}
  A \term{qubit} is a vector of two complex numbers \[ \vector{a b} \in \C^2 \]
  such that $|a|^2 + |b|^2 = 1$.  We define $\ket{0}$ and $\ket{1}$ to be the
  basis vectors \[ \ket{0} = \vector{1 0} \text{ and } \ket{1} = \vector{0
  1}, \] and will thus often write the above qubit as $a\ket{0} + b\ket{1}$.
  The general, non-basis, qubit states, where $a \ne 0$ and $b \ne 0$, are
  termed \term{superpositions}.  We call the coefficients $a$ and $b$
  \term{probability amplitudes}, for reasons which will become clear later.
\end{definition}

Now that we have this definition, we can define our first unitary operator:
bitwise negation, which we define as \[
  X = \begin{pmatrix} 0 & 1 \\
                      1 & 0 \end{pmatrix}.
\] Seeing that $X$ is unitary is straightforward, since it is both self-inverse
and Hermitian.  It is also easy to see that $X\ket{0} = \ket{1}$ and $X\ket{1} =
\ket{0}$, justifying the name bitwise negation.  But qubits are more than just
zeroes and ones.  If we apply bitwise negation to an arbitrary qubit $a\ket{0} +
b\ket{1}$, we get \[
  X(a\ket{0} + b\ket{1}) =
  \begin{pmatrix}
    0 & 1 \\
    1 & 0
  \end{pmatrix}
  \vector{a b} =
  \vector{b a} =
  b\ket{0} + a\ket{1}.
\]  Thus, bitwise negation swaps the probability amplitudes of an arbitrary
qubit.

\begin{figure}
  \centerline{\Qcircuit{
    \lstick{\ket{0}} & \gate{X} & \rstick{\ket{1}} \qw
  }}
  \caption{The quantum circuit diagram for applying the bitwise not operator to
    a single qubit; here, it is applied to the initial state $\ket{0}$.}
  \label{qcd:bitwise-not-0}
\end{figure}

Despite this ability to apply bitwise negation to non-basis vectors, it is still
essentially a traditional computational operation.  Can we define an operation
that will give us access to the more interesting qubit states we have opened
ourselves up to?  For this, we can define the \term{Hadamard transform} \[
  H = \frac{1}{\sqrt{2}}
      \begin{pmatrix} 1 & \pos1 \\
                      1 &    -1 \end{pmatrix}.
\] This matrix is also unitary since it is also self-inverse and Hermitian,
although this time we need a scaling factor of $1/\sqrt{2}$ to ensure that.  The
Hadamard transform will turn either of the basis vectors $\ket{0}$ or $\ket{1}$
into evenly-weighted superpositions of $\ket{0}$ and $\ket{1}$:
\begin{gather*}
  H\ket{0}
  = \frac{1}{\sqrt{2}}\begin{pmatrix} 1 & \pos1 \\ 1 & -1 \end{pmatrix}
    \vector{1 0}
  = \frac{1}{\sqrt{2}} \vector{1 1}
  = \frac{\ket{0} + \ket{1}}{\sqrt{2}}
\intertext{and}
  H\ket{1}
  = \frac{1}{\sqrt{2}}\begin{pmatrix} 1 & \pos1 \\ 1 & -1 \end{pmatrix}
    \vector{0 1}
  = \frac{1}{\sqrt{2}} \vector{\pos1 -1}
  = \frac{\ket{0} - \ket{1}}{\sqrt{2}}.
\end{gather*}
In the general case, we have \[
  H(a\ket{0} + b\ket{1})
  = \frac{1}{\sqrt{2}}\begin{pmatrix} 1 & \pos1 \\ 1 & -1 \end{pmatrix}
    \vector{a b}
  = \vector{a+b a-b}
  = \frac{(a+b)\ket{0} + (a-b)\ket{1}}{\sqrt{2}},
\]
so the Hadamard transform distributes the probability amplitudes of an arbitrary
qubit across both of its basis components.

\begin{figure}
  \centerline{\Qcircuit{
    \lstick{\ket{0}} &
    \gate{H} &
    \rstick{\displaystyle\frac{\ket{0}+\ket{1}}{\sqrt{2}}} \qw
  }}
  \caption{The quantum circuit diagram for applying the Hadamard transform to a
    single qubit; here, it is applied to the initial state $\ket{0}$.}
  \label{qcd:hadamard-0}
\end{figure}

We can also represent applying unitary transformations diagrammatically through
the use of a \term{quantum circuit diagram}, such as we see in
\cref{qcd:bitwise-not-0,qcd:hadamard-0}; \cref{qcd:bitwise-not-0} represents the
computation $X\ket{0} = \ket{1}$ and \cref{qcd:hadamard-0} represents the
computation $H\ket{0} = (\ket{0} + \ket{1})/\sqrt{2}$.  In these diagrams, the
horizontal lines are \term{wires} representing single qubits, and are read from
left to right.  A box which spans some wires and contains a term is a
\term{gate}; the effect of this gate is given by the unitary matrix within the
box, and the whole thing is to be read as applying that matrix to the given
qubits.\footnotemark{} The qubit labels at the left ends of the wires are the
input values; the qubit labels at the right end are the output values.
Sometimes, we will give a qubit a name as well as an initial value; the name
will be placed even further left.

\footnotetext{Our mathematically inclined readers might notice here that this is
  reminiscent of category theoretic diagrams, including composition happening in
  diagrammatic order.  This is indeed the case, which will be explained in more
  detail in \cref{sec:how}.}

This brings us nicely to the next property we must discuss: we talk above about
wire\emph{s}, plural.  But we haven't yet said how to define multi-qubit states!
Given two qubits $\ket{\phi}$ and $\ket{\psi}$, where $\ket{\phi} =
\phi_0\ket{0} + \phi_1\ket{1}$ and $\ket{\psi} = \psi_0\ket{0} + \psi_1\ket{1}$,
how can we talk about the system consisting of both $\ket{\phi}$ and
$\ket{\psi}$?  To those of us used to the traditional Newtonian worldview, this
is an odd question; can't we just use the pair $(\ket{\phi},\ket{\psi})$?  After
all, vector spaces are closed under the Cartesian product.

But here, too, quantum mechanics departs from our intuitions.  In quantum
mechanics, when we combine two state spaces, we take their \emph{tensor} product
instead.  For a fully formal definition of the tensor product \asz{Because \emph{I}
certainly can't define it.}, consult your favorite textbook on linear algebra,
such as \citeme{I dunno}; however, we define the relevant operations for the
finite-dimensional vector spaces that we care about.

\begin{definition}[Tensor product]\label{def:tensor-product}
  The \term{tensor product of vectors} $\ket{\phi} \in \C^m$ and $\ket{\psi} \in
  \C^n$ with zero-indexed entries $\phi_i$ and $\psi_j$, respectively, is the
  vector in $\C^{mn}$ whose entries are the pairwise products of the entries in
  $\ket{\phi}$ and the entries in $\ket{\psi}$.  More precisely, we have \[
    \ket{\phi} \tensor \ket{\psi} =
    \vector{\phi_0\ket{\psi} \phi_1\ket{\psi} \vdots{} \phi_{m-1}\ket{\psi}} =
    \vector{\phi_0\psi_0 \phi_0\psi_1 \vdots{} \phi_0\psi_{n-1}
            \phi_1\psi_0 \phi_1\psi_1 \vdots{} \phi_1\psi_{n-1}
            \vdots{}
            \phi_{m-1}\psi_0 \phi_{m-1}\psi_1 \vdots{} \phi_{m-1}\psi_{n-1}}
    \in \C^{mn}.
  \]  We also write this as $\ket{\phi}\ket{\psi}$ or $\ket{\phi\psi}$ if there
  will be no ambiguity.
  
  % "Internal" to the submatrix -- spacing is hard to come by here.
  \def\icdots{\mathclap{\cdots}}
  \def\iddots{\mathclap{\ddots}}
  The \term{tensor product of matrices} $U \in \C^{m \cross n}$ and $V \in \C^{p
  \cross q}$ with one-indexed\footnotemark{} entries $u_{ij}$ and $v_{ij}$,
  respectively, is the $mp \cross nq$ matrix whose entries are the pairwise
  products of the entries in $U$ and the entries in $V$.  More precisely, we
  have \begin{gather*}
    U \tensor V =
    \begin{pmatrix}
      u_{11}V & u_{21}V & \cdots & u_{m1}V \\
      u_{12}V & u_{22}V & \cdots & u_{m2}V \\
      \vdots & \vdots & \ddots & \vdots \\
      u_{1n}V & u_{2n}V & \cdots & u_{mn}V
    \end{pmatrix} \\ =
    \left(\begin{array}{@{}*{2}{c@{\;\;}ccc}cc@{\;\;}ccc@{}}
      u_{11}v_{11} & u_{11}v_{21} & \icdots & u_{11}v_{p1} &
      u_{21}v_{11} & u_{21}v_{21} & \icdots & u_{21}v_{p1} &
      \cdots &
      u_{m1}v_{11} & u_{m1}v_{21} & \icdots & u_{m1}v_{p1}
      \\
      u_{11}v_{12} & u_{11}v_{22} & \icdots & u_{11}v_{p2} &
      u_{21}v_{12} & u_{21}v_{22} & \icdots & u_{21}v_{p2} &
      \cdots &
      u_{m1}v_{12} & u_{m1}v_{22} & \icdots & u_{m1}v_{p2}
      \\
      \vdots & \vdots & \iddots & \vdots &
      \vdots & \vdots & \iddots & \vdots &
      \cdots &
      \vdots & \vdots & \iddots & \vdots
      \\
      u_{11}v_{1q} & u_{11}v_{2q} & \icdots & u_{11}v_{pq} &
      u_{21}v_{1q} & u_{21}v_{2q} & \icdots & u_{21}v_{pq} &
      \cdots &
      u_{m1}v_{1q} & u_{m1}v_{2q} & \icdots & u_{m1}v_{pq}
      \\
      \vdots & \vdots & \vdots & \vdots &
      \vdots & \vdots & \vdots & \vdots &
      \ddots &
      \vdots & \vdots & \vdots & \vdots
      \\
      u_{1n}v_{11} & u_{1n}v_{21} & \icdots & u_{1n}v_{p1} &
      u_{2n}v_{11} & u_{2n}v_{21} & \icdots & u_{2n}v_{p1} &
      \cdots &
      u_{mn}v_{11} & u_{mn}v_{21} & \icdots & u_{mn}v_{p1}
      \\
      u_{1n}v_{12} & u_{1n}v_{22} & \icdots & u_{1n}v_{p2} &
      u_{2n}v_{12} & u_{2n}v_{22} & \icdots & u_{2n}v_{p2} &
      \cdots &
      u_{mn}v_{12} & u_{mn}v_{22} & \icdots & u_{mn}v_{p2}
      \\
      \vdots & \vdots & \iddots & \vdots &
      \vdots & \vdots & \iddots & \vdots &
      \cdots &
      \vdots & \vdots & \iddots & \vdots
      \\
      u_{1n}v_{1q} & u_{1n}v_{2q} & \icdots & u_{1n}v_{pq} &
      u_{2n}v_{1q} & u_{2n}v_{2q} & \icdots & u_{2n}v_{pq} &
      \cdots &
      u_{mn}v_{1q} & u_{mn}v_{2q} & \icdots & u_{mn}v_{pq}
    \end{array}\right) \\ \in \C^{mp \cross nq}.
  \end{gather*}

  \footnotetext{Solely for space reasons.}
\end{definition}

Thus, when we are considering $n$-qubit systems, we find ourselves in a
$2^n$-dimensional complex vector space.  The basis vectors in this space are the
tensor products of the basis vectors in the original space; for instance, a
two-qubit system has the four basis vectors \[
\begin{array}{c@{\qquad}c}
  \ket{00} = \ket{0} \tensor \ket{0} =
  \vector{1 0} \tensor \vector{1 0} = \vector{1 0 0 0} &
  \ket{01} = \ket{0} \tensor \ket{1} =
  \vector{1 0} \tensor \vector{0 1} = \vector{0 1 0 0} \\[7ex]
  \ket{10} = \ket{1} \tensor \ket{0} =
  \vector{0 1} \tensor \vector{1 0} = \vector{0 0 1 0} &
  \ket{11} = \ket{1} \tensor \ket{1} =
  \vector{0 1} \tensor \vector{0 1} = \vector{0 0 0 1}
\end{array}
\]  Conveniently, this means that we can take the basis vector $\ket{b_{n-1}
\cdots b_0}$, where each of the $b_i$ are either $0$ or $1$, and read the name
$b_{n-1} \cdots b_0$ as a binary number $B$; if we do this, we find that this
basis vector is the one containing $0$s everywhere except for a $1$ at
(zero-based) index $B$.

The tensor product has another important property besides increasing the
dimension of the vector spaces involved multiplicatively instead of additively.
We know that given vector spaces $U$ and $V$, all elements of $U \cross V$ are
of the form $(u,v)$ for some $u \in U$ and $v \in V$.  But when we take the
tensor product of $U$ and $V$ instead, we find that there exist elements of $U
\tensor V$ that aren't of the form $u \tensor v$ for any $u \in U$ and $v \in
V$.  We call states of the form $u \tensor v$ \term{separable}, and all other
states \term{entangled}.

\begin{definition}[Separable and entangled states]%
\label{def:separable-entangled}
  A multi-qubit system is \term{separable} if it can be written as the tensor
  product of multiple smaller systems, and \term{entangled} if it cannot.  A
  state may be separable in one context but not in another; for instance, given
  the entangled two-qubit states $\ket{\phi}$ and $\ket{\psi}$, we may say that
  $\ket{\phi\psi}$ is entangled when thinking about one-qubit states, but that
  it is separable when thinking about two-qubit states.
\end{definition}

This is all well and good, but how do we produce entangled states?  To do this,
we need to introduce our first multi-qubit operator: the \term{controlled not}
gate, also known as the \term{cnot} gate.  You might expect a more traditional
choice like an and gate or an or gate.  However, recall that all quantum
operators must be unitary, and hence take $n$ qubits to $n$ qubits; ``and'' and
``or'' lose information.  The controlled not gate takes two qubits as input: a
control qubit and a target qubit.  The control qubit is unmodified; the second
qubit is bitwise negated if the control qubit is $\ket{1}$, and unmodified if
the control qubit is $\ket{0}$.  We can define this with the matrix \[
  \CNOT = \begin{pmatrix} 1 & 0 & 0 & 0 \\
                          0 & 1 & 0 & 0 \\
                          0 & 0 & 0 & 1 \\
                          0 & 0 & 1 & 0 \end{pmatrix}.
\] Seeing that $\CNOT$ is unitary is straightforward, since (like $X$ and $H$)
it is both self-inverse and Hermitian.  We can verify that, given a single-qubit
state $\ket{\psi} = \psi_0\ket{0} + \psi_1\ket{1}$, we have $\CNOT\ket{0\psi} =
\ket{0\psi}$ and $\CNOT\ket{1\psi} = \ket{1} \tensor X\ket{\psi}$:
\begin{align*}
  \CNOT\ket{0\psi} &=
  \begin{pmatrix} 1 & 0 & 0 & 0 \\
                  0 & 1 & 0 & 0 \\
                  0 & 0 & 0 & 1 \\
                  0 & 0 & 1 & 0 \end{pmatrix}
  \left[\vector{1 0} \tensor \vector{\psi_0 \psi_1}\right] =
  \begin{pmatrix} 1 & 0 & 0 & 0 \\
                  0 & 1 & 0 & 0 \\
                  0 & 0 & 0 & 1 \\
                  0 & 0 & 1 & 0 \end{pmatrix}
  \vector{\psi_0 \psi_1 0 0} \\ &=
  \vector{\psi_0 \psi_1 0 0} =
  \vector{1 0} \tensor \vector{\psi_0 \psi_1} =
  \ket{0\psi}
\intertext{and}
  \CNOT\ket{1\psi} &=
  \begin{pmatrix} 1 & 0 & 0 & 0 \\
                  0 & 1 & 0 & 0 \\
                  0 & 0 & 0 & 1 \\
                  0 & 0 & 1 & 0 \end{pmatrix}
  \left[\vector{0 1} \tensor \vector{\psi_0 \psi_1}\right] =
  \begin{pmatrix} 1 & 0 & 0 & 0 \\
                  0 & 1 & 0 & 0 \\
                  0 & 0 & 0 & 1 \\
                  0 & 0 & 1 & 0 \end{pmatrix}
  \vector{0 0 \psi_0 \psi_1} \\ &=
  \vector{0 0 \psi_1 \psi_0} =
  \vector{0 1} \tensor \vector{\psi_1 \psi_0} =
  \ket{1} \tensor X\ket{\psi}.
\end{align*}
However, things get more interesting when the first qubit is not simply
$\ket{0}$ or $\ket{1}$.  For instance, consider what happens when applying the
controlled not gate to the control $(\ket{0} + \ket{1})/\sqrt{2}$ and the target
$\ket{0}$.  Informally, since the control is equally both $\ket{0}$ and
$\ket{1}$, it should equally leave the target alone and invert it.  But since
the inversion happens only with a control of $\ket{1}$, the two qubits will be
correlated: we should expect that either both are $\ket{0}$ or both are
$\ket{1}$.  And indeed, when we work this out, we get the state $(\ket{00} +
\ket{11})/\sqrt{2}$:
\begin{align*}
  \CNOT\left[\frac{\ket{0} + \ket{1}}{\sqrt{2}} \tensor \ket{0}\right] &=
  \begin{pmatrix} 1 & 0 & 0 & 0 \\
                  0 & 1 & 0 & 0 \\
                  0 & 0 & 0 & 1 \\
                  0 & 0 & 1 & 0 \end{pmatrix}
  \left[\frac{1}{\sqrt{2}}\vector{1 1} \tensor \vector{1 0}\right] =
  \begin{pmatrix} 1 & 0 & 0 & 0 \\
                  0 & 1 & 0 & 0 \\
                  0 & 0 & 0 & 1 \\
                  0 & 0 & 1 & 0 \end{pmatrix}
  \left[\frac{1}{\sqrt{2}} \vector{1 0 1 0} \right] \\ &=
  \frac{1}{\sqrt{2}} \vector{1 0 0 1} =
  \frac{\ket{00} + \ket{11}}{\sqrt{2}}.
\end{align*}
And this state's correlation -- guaranteeing that both qubits must be the same,
but \emph{not} what value they must take -- means that it is entangled.  To see
this, suppose we had some separable two-qubit state composed of $\ket{\phi} =
\phi_0\ket{0} + \phi_1\ket{1}$ and $\ket{\psi} = \psi_0\ket{0} + \psi_1\ket{1}$;
this is of the form \[ \ket{\phi\psi} = \phi_0\psi_0\ket{00} +
\phi_0\psi_1\ket{01} + \phi_1\psi_0\ket{10} + \phi_1\psi_1\ket{11}. \]  Thus,
the state above is separable if and only if we have the equality \[
\frac{\ket{00} + \ket{11}}{\sqrt{2}} = \phi_0\psi_0\ket{00} +
\phi_0\psi_1\ket{01} + \phi_1\psi_0\ket{10} + \phi_1\psi_1\ket{11}, \] which
splits up into \[ \phi_0\psi_0 = \phi_1\psi_1 = \frac{1}{\sqrt{2}}
\quad\text{and}\quad \phi_0\psi_1 = \phi_1\psi_0 = 0. \]  The two equalities
with $1/\sqrt{2}$ tell us that none of the $\phi_i$ or $\psi_i$ are $0$;
however, the two equalities with $0$ require that at least two of them are.
This is impossible, and so $(\ket{00} + \ket{11})/2$ is entangled.

\begin{figure}
  \centerline{\Qcircuit{
    \lstick{\ket{0}} & \ctrl{1} & \rstick{\ket{0}} \qw \\
    \lstick{\ket{0}} & \targ    & \rstick{\ket{0}} \qw \\
  }}
  \caption{The quantum circuit diagram for applying the controlled not gate to
    two qubits; here, it is applied to the initial state $\ket{00}$.}
  \label{qcd:cnot-00}
\end{figure}

\begin{figure}
  \centerline{\Qcircuit{
    \lstick{\ket{0}} &
      \gate{H} &
      \qw & \qw \qcmark{2} & \qw &
      \ctrl{1} &
    \rstick{\tikz[overlay]
      \draw[decorate,decoration={brace, amplitude=1em}]
      (0,1em) -- (0,-4.1em)
      node[midway,right=1.5em]
        {$\displaystyle \frac{\ket{00} + \ket{11}}{\sqrt{2}}$} ;} \qw
    \\
    \lstick{\ket{0}} &
      \qw &
      \qw & \dstick{\raisebox{-2.67
em}{$\displaystyle
              \frac{\ket{0} + \ket{1}}{\sqrt{2}} \tensor \ket{0}$}} \qw &
            \qw &
      \targ &
    \qw \\
    & \\ & % For space -- but TODO, a little too much!
  }}
  \caption{The quantum circuit diagram for applying the controlled not gate to
    two qubits; here, it is applied to the initial state $\ket{00}$.}
  \label{qcd:entangle-2-equal}
\end{figure}

Diagrammatically, we represent the controlled not gate, not with a box, but with
a \term{control}~``$\bullet$'' and a \term{target}~``$\oplus$''; this represents
applying $\CNOT$ to the two-qubit state
$\ket{\mathit{control}}\ket{\mathit{target}}$.  \Cref{qcd:cnot-00} shows what
this looks like when evaluating $\CNOT\ket{00}$.  This is a no-op, so the
diagram is pretty boring; \cref{qcd:entangle-2-equal} instead shows how to use
the controlled not gate to entangle two qubits so that they must be equal;
specifically, into the state $(\ket{00} + \ket{11})/\sqrt{2}$.  First, we use
the Hadamard gate to put the first qubit into the state $(\ket{0} +
\ket{1})/\sqrt{2}$; then, we use the controlled not gate to entangle the qubit,
as we discussed above.

If we wanted to write this circuit out as a matrix, though, what would we do?
We have applied the Hadamard gate only to the first qubit, even though we have a
two-qubit quantum state.  The answer is that when we apply a unitary matrix $U$
to some qubits, we tensor it with appropriately sized identity matrices to get a
matrix that acts on all the qubits at once.  This works because $(U \tensor
V)(\ket{\phi} \tensor \ket{\psi}) = U\ket{\phi} \tensor V\ket{\psi}$; this is
easy to see, but we omit the proof, as it is entirely straightforward but messy
algebra.

Consequently, to entangle two $\ket{0}$ qubits, we apply the matrix $\CNOT
\mtimes (H \tensor I_2)$ (remember, diagrammatic composition goes the opposite
order from the composition or multiplication operator).  Applying $H \tensor
I_2$ produces the state marked at the dashed line; applying $\CNOT$ entangles
the two qubits.  Working out the matrix algebra directly, we get
\begin{align*}
  \CNOT \mtimes (H \tensor I_2) \mtimes \ket{00}
  &= \begin{pmatrix}
       1 & 0 & 0 & 0 \\
       0 & 1 & 0 & 0 \\
       0 & 0 & 0 & 1 \\
       0 & 0 & 1 & 0
     \end{pmatrix}
     \left[
       \frac{1}{\sqrt{2}}
       \begin{pmatrix}
         1 & \pos1 \\
         1 &    -1
       \end{pmatrix}
       \tensor
       \begin{pmatrix}
         1 & 0 \\
         0 & 1
       \end{pmatrix}
     \right]
     \ket{00} \\
  &= \frac{1}{\sqrt{2}}
     \begin{pmatrix}
       1 & 0 & 0 & 0 \\
       0 & 1 & 0 & 0 \\
       0 & 0 & 0 & 1 \\
       0 & 0 & 1 & 0
     \end{pmatrix}
     \begin{pmatrix}
       1 & 0 & \pos1 & \pos0 \\
       0 & 1 & \pos0 & \pos1 \\
       1 & 0 &    -1 & \pos0 \\
       0 & 1 & \pos0 &    -1
     \end{pmatrix}
     \ket{00} \\
  &= \frac{1}{\sqrt{2}}
     \begin{pmatrix}
       1 & 0 & \pos1 & \pos0 \\
       0 & 1 & \pos0 & \pos1 \\
       0 & 1 & \pos0 &    -1 \\
       1 & 0 &    -1 & \pos0
     \end{pmatrix}
     \ket{00} \\
  &= \frac{1}{\sqrt{2}}
     \begin{pmatrix}
       1 & 0 & \pos1 & \pos0 \\
       0 & 1 & \pos0 & \pos1 \\
       0 & 1 & \pos0 &    -1 \\
       1 & 0 &    -1 & \pos0
     \end{pmatrix}
     \vector{1 0 0 0} \\
  &= \frac{1}{\sqrt{2}}\vector{1 0 0 1}
   = \frac{\ket{00} + \ket{11}}{\sqrt{2}}.
\end{align*}
